<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algos on WHS Comp. Sci. Club</title>
    <link>https://whscompsciclub.github.io/algos/</link>
    <description>Recent content in Algos on WHS Comp. Sci. Club</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC-BY-NC-SA 4.0 | WHS CSC {year}</copyright>
    <lastBuildDate>Tue, 09 Feb 2021 00:00:00 -0800</lastBuildDate><atom:link href="https://whscompsciclub.github.io/algos/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Searching Algorithms</title>
      <link>https://whscompsciclub.github.io/algos/search/</link>
      <pubDate>Tue, 09 Feb 2021 00:00:00 -0800</pubDate>
      
      <guid>https://whscompsciclub.github.io/algos/search/</guid>
      <description>Linear Search  prerequisites  none   how it works  iterates one at a time from left to right   advantages  simple to implement   example  when searching through a phone book for an entry under W go page-by-page until you reach W   O(n)  Binary Search  prerequisites  the array must be sorted   how it works  start at the middle and check the value if the value is less  check the middle value of the left half   else the value is greater  check the middle value of the right half   repeat until the value is found   advantages  much faster than linear search, especially as n increases   example  when searching through a phone book for an entry under W start at M (middle of A-Z) W &amp;gt; M so check T (middle of M-Z) W &amp;gt; T so check W (middle of T-Z) W = W so we&amp;rsquo;re done   O(log(n)) Check out this article to learn more about Binary Search  Jump Search  prerequisites  the array must be sorted (like Binary Search) traverses the array in &amp;ldquo;jumps&amp;rdquo; of âˆšn (n being the array length)   how it works  once the number being checked is greater than the target number,</description>
    </item>
    
    <item>
      <title>Recursion</title>
      <link>https://whscompsciclub.github.io/algos/recursion/</link>
      <pubDate>Thu, 21 Jan 2021 00:00:00 -0800</pubDate>
      
      <guid>https://whscompsciclub.github.io/algos/recursion/</guid>
      <description>Recursive Function  A function that calls itself Solves problems by solving smaller instances of the same problem until the problem is so small it can be solved directly (also see Recursive Function )  Russian Doll A russian doll is a good example of recursion, as it gets smaller and smaller until there exists a doll that is too small to contain another doll
Parts to a Recursive Function  A simply case: can be solved directly A complex case: can be made simpler (and simpler &amp;hellip; until it looks like the simple case)  Factorial Find the factorial of n using recursion</description>
    </item>
    
    <item>
      <title>Intro to Sorting Algorithms</title>
      <link>https://whscompsciclub.github.io/algos/intro-sort/</link>
      <pubDate>Sun, 06 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://whscompsciclub.github.io/algos/intro-sort/</guid>
      <description>We use sorting algorithms to keep an array in order. Here is a list of common sorting algorithms. Beware: the first three are highly inefficient! (See Time Complexity )
Bubble Sort: $O(n^2)$  Set the first element as the current element. swap(current, next) if current &amp;gt; next, essentially moving it down the list Repeat last step.  if current &amp;lt; next: set next as the current element if current = end of list: set the first element as the current element   The array is sorted when no swaps occur in a single pass (from first to last).</description>
    </item>
    
    <item>
      <title>Time Complexity</title>
      <link>https://whscompsciclub.github.io/algos/time-complexity/</link>
      <pubDate>Thu, 03 Dec 2020 00:00:00 -0800</pubDate>
      
      <guid>https://whscompsciclub.github.io/algos/time-complexity/</guid>
      <description>In computer science, analysis of algorithms is a very crucial part. It is important to find the most efficient algorithm for solving a problem. It is possible to have many algorithms to solve a problem, but the challenge here is to choose the most efficient one.
  Now the point is, how can we recognize the most efficient algorithm if we have a set of different algorithms? Here, the concept of space and time complexity of algorithms comes into existence.</description>
    </item>
    
    <item>
      <title>Brute Force</title>
      <link>https://whscompsciclub.github.io/algos/brute-force/</link>
      <pubDate>Wed, 02 Dec 2020 00:00:00 -0800</pubDate>
      
      <guid>https://whscompsciclub.github.io/algos/brute-force/</guid>
      <description>What is Brute Forcing? A brute-force problem is exactly what it sounds like: simply doing everything possible to eventually reach the answer. Let&amp;rsquo;s say you were trying to achieve the password to someone&amp;rsquo;s phone (assume 4 digits from 0 to 9). A brute force solution would be to try every single password possible. This way, it is guaranteed that at one point, the answer would be correct.  Pros  Easy/Uncomplicated Guarantees a solution   Cons  Inefficient Not suitable for every problem    Brute Force in the USACO  It is almost guaranteed that there will be at least one brute force problem in a USACO Bronze contest, and sometimes there will be 2 (and rarely 3).</description>
    </item>
    
  </channel>
</rss>
