<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algos on WHS Comp. Sci. Club</title>
    <link>https://whscompsciclub.github.io/algos/</link>
    <description>Recent content in Algos on WHS Comp. Sci. Club</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC-BY-NC-SA 4.0 | WHS CSC {year}</copyright>
    <lastBuildDate>Tue, 09 Feb 2021 00:00:00 -0800</lastBuildDate><atom:link href="https://whscompsciclub.github.io/algos/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Searching Algorithms</title>
      <link>https://whscompsciclub.github.io/algos/search/</link>
      <pubDate>Tue, 09 Feb 2021 00:00:00 -0800</pubDate>
      
      <guid>https://whscompsciclub.github.io/algos/search/</guid>
      <description>Linear Search Binary Search Jump Search  prerequisites  the array must be sorted (like Binary Search) traverses the array in &amp;ldquo;jumps&amp;rdquo; of √n (n being the array length)   how it works  once the number being checked is greater than the target number,
jump √n back and then linear search forwards   advantages  unlike binary search, jump search only jumps backwards once in a scenario in which jumping backward is costly,</description>
    </item>
    
    <item>
      <title>Recursion</title>
      <link>https://whscompsciclub.github.io/algos/recursion/</link>
      <pubDate>Thu, 21 Jan 2021 00:00:00 -0800</pubDate>
      
      <guid>https://whscompsciclub.github.io/algos/recursion/</guid>
      <description>Recursive Function  A function that calls itself Solves problems by solving smaller instances of the same problem until the problem is so small it can be solved directly (also see Recursive Function )  Russian Doll A russian doll is a good example of recursion, as it gets smaller and smaller until there exists a doll that is too small to contain another doll
Parts to a Recursive Function  A simply case: can be solved directly A complex case: can be made simpler (and simpler &amp;hellip; until it looks like the simple case)  Factorial Find the factorial of n using recursion</description>
    </item>
    
    <item>
      <title>Intro to Sorting Algorithms</title>
      <link>https://whscompsciclub.github.io/algos/intro-sort/</link>
      <pubDate>Sun, 06 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://whscompsciclub.github.io/algos/intro-sort/</guid>
      <description>We use sorting algorithms to keep an array in order. Here is a list of common sorting algorithms. Beware: the first three are highly inefficient! (See Time Complexity )
Bubble Sort: $O(n^2)$  Set the first element as the current element. swap(current, next) if current &amp;gt; next, essentially moving it down the list Repeat last step.  if current &amp;lt; next: set next as the current element if current = end of list: set the first element as the current element   The array is sorted when no swaps occur in a single pass (from first to last).</description>
    </item>
    
    <item>
      <title>Time Complexity</title>
      <link>https://whscompsciclub.github.io/algos/time-complexity/</link>
      <pubDate>Thu, 03 Dec 2020 00:00:00 -0800</pubDate>
      
      <guid>https://whscompsciclub.github.io/algos/time-complexity/</guid>
      <description>In computer science, analysis of algorithms is a very crucial part. It is important to find the most efficient algorithm for solving a problem. It is possible to have many algorithms to solve a problem, but the challenge here is to choose the most efficient one.
  Now the point is, how can we recognize the most efficient algorithm if we have a set of different algorithms? Here, the concept of space and time complexity of algorithms comes into existence.</description>
    </item>
    
    <item>
      <title>Brute Force</title>
      <link>https://whscompsciclub.github.io/algos/brute-force/</link>
      <pubDate>Wed, 02 Dec 2020 00:00:00 -0800</pubDate>
      
      <guid>https://whscompsciclub.github.io/algos/brute-force/</guid>
      <description>What is Brute Forcing? A brute-force problem is exactly what it sounds like: simply doing everything possible to eventually reach the answer. Let&amp;rsquo;s say you were trying to achieve the password to someone&amp;rsquo;s phone (assume 4 digits from 0 to 9). A brute force solution would be to try every single password possible. This way, it is guaranteed that at one point, the answer would be correct.  Pros  Easy/Uncomplicated Guarantees a solution   Cons  Inefficient Not suitable for every problem    Brute Force in the USACO  It is almost guaranteed that there will be at least one brute force problem in a USACO Bronze contest, and sometimes there will be 2 (and rarely 3).</description>
    </item>
    
  </channel>
</rss>
